# main.py (Final Version with Enhanced DisplayName Parsing)

import subprocess
import time
import streamlit as st
import os
import uuid
import json
import re
import tempfile
import shutil
import glob

# --- 基礎 URL 與路徑設定 ---
BASE_URL = "https://missav.ws/"
DOWNLOAD_DIR = "D:\IDM Download\Adult video"

# --- 基本設定 ---
st.set_page_config(
    page_title="MrJet WebGUI",
    page_icon="random",
    layout="centered",
    initial_sidebar_state="auto",
)

static_dir = os.path.join(os.getcwd(), "static")
queue_file = os.path.join(os.getcwd(), "download_queue.json")
if not os.path.exists(static_dir):
    os.makedirs(static_dir)

# --- 佇列管理 ---
def load_queue():
    if os.path.exists(queue_file):
        with open(queue_file, "r") as f:
            return json.load(f)
    return {}

def save_queue(queue):
    with open(queue_file, "w") as f:
        json.dump(queue, f, indent=4)

if "download_queue" not in st.session_state:
    st.session_state.download_queue = load_queue()

# --- 核心輔助函式 ---
def normalize_id(text):
    return text.lower().replace('-', '')

# --- 【舊有修復功能，保持不變】 ---
def fix_video_and_overwrite(input_file):
    dir_name = os.path.dirname(input_file)
    with tempfile.NamedTemporaryFile(dir=dir_name, suffix='.mp4', delete=False) as tmpfile:
        temp_name = tmpfile.name
    
    cmd = [
        'ffmpeg', '-y', '-i', input_file,
        '-c', 'copy', '-movflags', 'faststart', temp_name
    ]
    try:
        print(f"執行修復: {input_file}")
        subprocess.run(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, check=True)
        shutil.move(temp_name, input_file)
        print(f"修复并覆盖完成: {input_file}")
        return True
    except subprocess.CalledProcessError as e:
        print(f"!! 修复失败: {input_file}\n{e.stderr.decode()}")
        if os.path.exists(temp_name):
            os.remove(temp_name)
        return False

def find_and_fix_video(display_name, download_dir):
    normalized_name = normalize_id(display_name)
    target_file = None
    for filename in os.listdir(download_dir):
        if os.path.isfile(os.path.join(download_dir, filename)):
            file_base, _ = os.path.splitext(filename)
            if normalized_name in normalize_id(file_base):
                target_file = os.path.join(download_dir, filename)
                print(f"找到匹配文件: {target_file}")
                break
    
    if target_file:
        return fix_video_and_overwrite(target_file)
    else:
        print(f"!! 未能在目录 {download_dir} 中找到与 {display_name} 匹配的文件。")
        return False

# --- 【全新功能】尋找 mrjet 快取資料夾 ---
def find_latest_mrjet_cache_folder():
    temp_dir = tempfile.gettempdir()
    search_pattern = os.path.join(temp_dir, '??????????')
    potential_folders = glob.glob(search_pattern)
    
    valid_folders = [
        f for f in potential_folders 
        if os.path.isdir(f) and os.path.basename(f).isalnum()
    ]
    
    if not valid_folders:
        return None
        
    latest_folder = max(valid_folders, key=os.path.getctime)
    
    try:
        if any(f.endswith('.mp4') for f in os.listdir(latest_folder)):
            print(f"找到最新的 mrjet 快取資料夾: {latest_folder}")
            return latest_folder
        else:
            print(f"找到疑似資料夾 {latest_folder}，但內部沒有 .mp4 分片，忽略。")
            return None
    except OSError as e:
        print(f"!! 存取資料夾 {latest_folder} 時發生錯誤: {e}")
        return None

# --- 【全新功能】使用 FFmpeg 接管合併 ---
def takeover_with_ffmpeg(cache_folder, output_path):
    try:
        print(f"FFmpeg 接管開始: {cache_folder}")

        print(f"初步獲取分片列表，等待 10 秒以確認文件寫入穩定...")
        initial_files = [f for f in os.listdir(cache_folder) if f.endswith('.mp4')]
        time.sleep(10) 
        final_files = [f for f in os.listdir(cache_folder) if f.endswith('.mp4')]
        print(f"初步獲取 {len(initial_files)} 個，10秒後獲取 {len(final_files)} 個。")

        if len(initial_files) != len(final_files):
            print(f"!! 检测到文件仍在增加，mrjet 可能仍在运行。放弃本次接管。")
            return "keep_going"

        print("文件數量穩定，開始執行合併...")
        mp4_files = final_files
        
        if not mp4_files:
            print("!! 錯誤: 快取資料夾中沒有找到 .mp4 分片檔案。")
            return False

        mp4_files_sorted = sorted(mp4_files, key=lambda x: int(re.search(r'\d+', x).group()))
        
        playlist_path = os.path.join(cache_folder, "ffmpeg_playlist.txt")
        with open(playlist_path, "w", encoding='utf-8') as f:
            for filename in mp4_files_sorted:
                f.write(f"file '{os.path.join(cache_folder, filename)}'\n")

        cmd = [
            'ffmpeg', '-y', '-f', 'concat', '-safe', '0', 
            '-i', playlist_path, '-c', 'copy', output_path
        ]
        
        print(f"執行 FFmpeg 合併命令...")
        subprocess.run(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, check=True)
        
        print(f"FFmpeg 合併成功: {output_path}")
        print(f"开始清理快取资料夹: {cache_folder}")
        shutil.rmtree(cache_folder, ignore_errors=True)
        print("清理完成。")
        return True

    except FileNotFoundError:
        st.error("FFmpeg 未安裝或未加入到系統環境變數中！接管失敗。")
        print("!! 致命錯誤: FFmpeg not found.")
        return False
    except subprocess.CalledProcessError as e:
        print(f"!! FFmpeg 合併過程中發生錯誤: {output_path}")
        print(e.stderr.decode())
        shutil.rmtree(cache_folder, ignore_errors=True)
        return False
    except Exception as e:
        print(f"!! 接管過程中發生未知錯誤: {e}")
        shutil.rmtree(cache_folder, ignore_errors=True)
        return False

# --- 【已修改】核心下載與狀態檢查 ---
def download_file(video_url_input):
    log_id = uuid.uuid4()
    log_file_path = os.path.join(static_dir, f"{log_id}.log")
    command = f"mrjet --url \"{video_url_input}\" --output_dir \"{DOWNLOAD_DIR}\""
    
    my_env = os.environ.copy()
    my_env["PYTHONIOENCODING"] = "utf-8"
    
    with open(log_file_path, "w", encoding='utf-8') as log_file:
        subprocess.Popen(
            command, stdout=log_file, stderr=subprocess.STDOUT, 
            text=True, shell=True, env=my_env
        )
        
    log_link = f"[logfile](./app/static/{log_id}.log)"
    return ":orange-background[Downloading]", log_link

def check_task_status_and_progress(url, log_link):
    if not log_link:
        return ":gray-background[Not Started]", 0.0, ""

    log_file = log_link.split("/static/")[1].split(")")[0]
    log_path = os.path.join(static_dir, log_file)
    
    current_progress = 0.0
    status = ":orange-background[Downloading]"

    if not os.path.exists(log_path):
        return ":red-background[Failed - Log Missing]", 0.0, log_link

    try:
        with open(log_path, "r", encoding='utf-8', errors='ignore') as f:
            content = f.read()

        download_matches = re.findall(r"Download\s*:\s*\[[^\]]*\]\s*([0-9\.]+)%", content)
        if download_matches: 
            current_progress = float(download_matches[-1]) / 100.0

        build_matches = re.findall(r"Build\s*:\s*\[[^\]]*\]\s*([0-9\.]+)%", content)
        if build_matches and float(build_matches[-1]) >= 100.0:
            status, current_progress = ":green-background[Success]", 1.0
        
        if ("Error" in content or "ERROR:" in content) and "Logging error" not in content:
            status = ":red-background[Failed]"

    except Exception as e:
        print(f"Error processing log file {log_path}: {e}")
        pass
    
    return status, current_progress, log_link

# --- Streamlit 介面 ---
st.title("MrJet WebGUI")
st.text_area(
    label="Enter one or more AV Numbers / URLs",
    placeholder="You can enter multiple items, separated by commas, spaces, or newlines.\ne.g.,\nwaaa-361, ssis-001",
    key="url_input_val"
)
add_col, start_col = st.columns((1, 5))
with add_col:
    add_button = st.button("Add", use_container_width=True)
with start_col:
    start_button = st.button("Start All Queued", use_container_width=True)

# --- 狀態更新與自動接管邏輯 ---
for url, task in list(st.session_state.download_queue.items()):
    if task["Status"] == ":orange-background[Downloading]":
        status, progress, log = check_task_status_and_progress(url, task["Log"])
        st.session_state.download_queue[url]["Progress_Download"] = progress
        
        is_stalled = False
        if progress == task.get("LastProgressValue", -1):
            stalled_time = time.time() - task.get("LastProgressTime", 0)
            if stalled_time > 30:
                is_stalled = True
        else:
            st.session_state.download_queue[url]["LastProgressValue"] = progress
            st.session_state.download_queue[url]["LastProgressTime"] = time.time()

        if is_stalled and progress >= 0.95:
            st.warning(f"任務 {task['DisplayName']} 進度停滯在 {progress*100:.0f}% 超過30秒，嘗試FFmpeg接管...")
            print(f"接管觸發: {task['DisplayName']}")
            cache_folder = find_latest_mrjet_cache_folder()
            if cache_folder:
                output_filename = f"{task['DisplayName']}.mp4"
                output_path = os.path.join(DOWNLOAD_DIR, output_filename)
                
                takeover_result = takeover_with_ffmpeg(cache_folder, output_path)
                
                if takeover_result is True:
                    st.session_state.download_queue[url]["Status"] = ":green-background[Completed]"
                    st.session_state.download_queue[url]["Log"] += " (Takeover)"
                    st.success(f"任務 {task['DisplayName']} 已由 FFmpeg 成功接管並完成！")
                elif takeover_result == "keep_going":
                    print("接管被推迟，等待下一次检查...")
                    st.session_state.download_queue[url]["LastProgressTime"] = time.time()
                else: 
                    st.session_state.download_queue[url]["Status"] = ":red-background[Takeover Failed]"
            else:
                print("!! 接管失敗: 找不到 mrjet 快取資料夾。")
                st.session_state.download_queue[url]["Status"] = ":red-background[Cache Not Found]"

        if status != ":orange-background[Downloading]":
            st.session_state.download_queue[url]["Status"] = status

    if task["Status"] == ":green-background[Success]":
        st.session_state.download_queue[url]["Status"] = ":blue-background[Fixing]"

    if task["Status"] == ":blue-background[Fixing]":
        fix_success = find_and_fix_video(task["DisplayName"], DOWNLOAD_DIR)
        if fix_success:
            st.session_state.download_queue[url]["Status"] = ":green-background[Completed]"
        else:
            st.session_state.download_queue[url]["Status"] = ":red-background[Fix Failed]"

save_queue(st.session_state.download_queue)

# --- 佇列顯示 ---
st.markdown("---")
if not st.session_state.download_queue:
    st.info("The download queue is empty.")
else:
    for url, task in st.session_state.download_queue.items():
        main_cols = st.columns((5, 3, 2))
        main_cols[0].markdown(f'**ID:** [{task["DisplayName"]}]({url})')
        main_cols[1].text(f'Created: {task["Created Date"]}')
        main_cols[2].markdown(f'**{task["Status"]}** {task["Log"]}')
        
        st.text("Download Progress:")
        if task["Status"] in [":green-background[Completed]", ":blue-background[Fixing]"]:
            st.progress(1.0)
        else:
            st.progress(task.get("Progress_Download", 0.0))
        st.markdown("---")

# --- 按鈕邏輯 (已更新番号提取功能) ---
if add_button and st.session_state.url_input_val:
    raw_input = st.session_state.url_input_val
    normalized_input = raw_input.replace(',', ' ').replace('\n', ' ')
    items_to_add = [item.strip() for item in normalized_input.split(' ') if item.strip()]
    added_count, skipped_count, exist_count = 0, 0, 0
    existing_files_list = []

    try:
        if not os.path.isdir(DOWNLOAD_DIR):
            st.error(f"Download directory not found: {DOWNLOAD_DIR}. Please create it or correct the path.")
            existing_filenames_normalized = []
        else:
            existing_filenames_normalized = [normalize_id(f) for f in os.listdir(DOWNLOAD_DIR) if os.path.isfile(os.path.join(DOWNLOAD_DIR, f))]
    except Exception as e:
        st.error(f"Error accessing download directory {DOWNLOAD_DIR}: {e}")
        existing_filenames_normalized = []

    for user_input in items_to_add:
        # 預先對輸入進行標準化，以進行重複檢查
        # 注意：這裡的標準化僅用於檢查，不影響 display_name
        check_name = user_input.split('#')[0].strip('/').split('/')[-1]
        normalized_check_name = normalize_id(check_name)

        if any(normalized_check_name in filename for filename in existing_filenames_normalized):
            exist_count += 1
            existing_files_list.append(check_name)
            continue

        if not user_input.startswith("http"):
            full_url = f"{BASE_URL}{user_input}"
            display_name = user_input
        else:
            full_url = user_input
            url_cleaned = user_input.split('#')[0]
            url_cleaned = url_cleaned.strip('/')
            display_name = url_cleaned.split('/')[-1] or user_input
            
        if full_url not in st.session_state.download_queue:
            st.session_state.download_queue[full_url] = {
                "DisplayName": display_name, "Created Date": time.strftime("%Y-%m-%d %H:%M:%S"),
                "Status": ":gray-background[Not Started]", "Log": "",
                "Progress_Download": 0.0,
                "LastProgressValue": -1.0,
                "LastProgressTime": 0.0,
            }
            added_count += 1
        else:
            skipped_count += 1
    
    if added_count > 0: st.success(f"Successfully added {added_count} new item(s).")
    if skipped_count > 0: st.warning(f"Skipped {skipped_count} item(s) already in queue.")
    if exist_count > 0: st.error(f"Skipped {exist_count} item(s) that may already exist: {', '.join(existing_files_list)}")
    
    if added_count > 0:
        save_queue(st.session_state.download_queue)
        st.rerun()

# --- 啟動邏輯 ---
if start_button:
    for url, task in st.session_state.download_queue.items():
        if task["Status"] == ":gray-background[Not Started]":
            status, log_link = download_file(url)
            st.session_state.download_queue[url]["Status"] = status
            st.session_state.download_queue[url]["Log"] = log_link
            st.session_state.download_queue[url]["LastProgressTime"] = time.time()
            st.session_state.download_queue[url]["LastProgressValue"] = 0.0
            
    save_queue(st.session_state.download_queue)
    st.rerun()

# --- 其他部分 ---
with st.expander("Utils", expanded=False):
    if st.button("Clean finished tasks"):
        urls_to_remove = [
            url for url, task in st.session_state.download_queue.items() 
            if task["Status"] not in [":orange-background[Downloading]", ":gray-background[Not Started]"]
        ]
        for url in urls_to_remove:
            task = st.session_state.download_queue[url]
            if task["Log"] and "Takeover" not in task["Log"]:
                log_file = task["Log"].split("/static/")[1].split(")")[0]
                log_path = os.path.join(static_dir, log_file)
                if os.path.exists(log_path): os.remove(log_path)
            del st.session_state.download_queue[url]
        save_queue(st.session_state.download_queue)
        st.rerun()

is_processing = any(
    task["Status"] == ":orange-background[Downloading]"
    for task in st.session_state.download_queue.values()
)
if is_processing:
    time.sleep(5) 
    st.rerun()