# main.py (Final Version with Auto-Fixing Integration)

import subprocess
import time
import streamlit as st
import os
import uuid
import json
import re
# 【新增】导入新增功能所需的库
import tempfile
import shutil

# --- 基础 URL 与路徑設定 ---
BASE_URL = "https://missav.ws/"
# 【新增】请在此处设定你的影片下载资料夹
DOWNLOAD_DIR = "D:\IDM Download"

# --- 基本設定 ---
st.set_page_config(
    page_title="MrJet WebGUI",
    page_icon="random",
    layout="centered",
    initial_sidebar_state="auto",
)

static_dir = os.path.join(os.getcwd(), "static")
queue_file = os.path.join(os.getcwd(), "download_queue.json")
if not os.path.exists(static_dir):
    os.makedirs(static_dir)

# --- 佇列管理 ---
def load_queue():
    if os.path.exists(queue_file):
        with open(queue_file, "r") as f:
            return json.load(f)
    return {}

def save_queue(queue):
    with open(queue_file, "w") as f:
        json.dump(queue, f, indent=4)

if "download_queue" not in st.session_state:
    st.session_state.download_queue = load_queue()

# --- 核心輔助函式 ---
def normalize_id(text):
    """將輸入的字串轉為小寫並移除連字號，用於比對。"""
    return text.lower().replace('-', '')

# --- 【新增】从你的脚本中整合的核心修复功能 ---
def fix_video_and_overwrite(input_file):
    """
    使用 FFmpeg 的 -movflags faststart 无损修复影片，并覆盖原文件。
    这可以解决无法拖动进度条的问题。
    """
    dir_name = os.path.dirname(input_file)
    # 创建一个安全的临时文件
    with tempfile.NamedTemporaryFile(dir=dir_name, suffix='.mp4', delete=False) as tmpfile:
        temp_name = tmpfile.name
    
    cmd = [
        'ffmpeg',
        '-y',               # 如果临时文件已存在，则覆盖
        '-i', input_file,
        '-c', 'copy',       # 无损复制所有流
        '-movflags', 'faststart', # 核心！将索引移到文件头部
        temp_name
    ]
    try:
        print(f"执行修复: {input_file}")
        # 使用 check=True，如果 ffmpeg 失败会抛出异常
        subprocess.run(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, check=True)
        # 修复成功后，用临时文件安全地覆盖原始文件
        shutil.move(temp_name, input_file)
        print(f"修复并覆盖完成: {input_file}")
        return True
    except subprocess.CalledProcessError as e:
        print(f"!! 修复失败: {input_file}")
        print(e.stderr.decode()) # 打印出 ffmpeg 的错误信息，便于排查
        # 如果失败，清理掉生成的临时文件
        if os.path.exists(temp_name):
            os.remove(temp_name)
        return False

# --- 【新增】寻找并修复已完成下载的文件 ---
def find_and_fix_video(display_name, download_dir):
    """
    在下载目录中根据 display_name 寻找对应的视频文件，并执行修复。
    """
    normalized_name = normalize_id(display_name)
    target_file = None

    # 遍历下载目录，寻找匹配的文件（忽略大小写和连字符）
    for filename in os.listdir(download_dir):
        # 确保我们只处理文件，不处理文件夹
        if os.path.isfile(os.path.join(download_dir, filename)):
            file_base, _ = os.path.splitext(filename)
            if normalized_name in normalize_id(file_base):
                target_file = os.path.join(download_dir, filename)
                print(f"找到匹配文件: {target_file}")
                break
    
    if target_file:
        # 如果找到文件，则调用修复函数
        return fix_video_and_overwrite(target_file)
    else:
        print(f"!! 未能在目录 {download_dir} 中找到与 {display_name} 匹配的文件。")
        return False

# --- 核心功能函式 (下载与状态检查) ---
def download_file(video_url_input):
    log_id = uuid.uuid4()
    log_file_path = os.path.join(static_dir, f"{log_id}.log")
    command = f"mrjet --url \"{video_url_input}\" --output_dir \"{DOWNLOAD_DIR}\""
    with open(log_file_path, "w", encoding='utf-8') as log_file:
        subprocess.Popen(
            command, stdout=log_file, stderr=subprocess.STDOUT, text=True, shell=True
        )
    log_link = f"[logfile](./app/static/{log_id}.log)"
    return ":orange-background[Downloading]", log_link

def check_task_status_and_progress(url, log_link):
    if not log_link:
        return ":gray-background[Not Started]", 0.0, 0.0, 0.0, ""

    log_file = log_link.split("/static/")[1].split(")")[0]
    log_path = os.path.join(static_dir, log_file)
    
    verify_p, download_p, build_p = 0.0, 0.0, 0.0
    status = ":orange-background[Downloading]"

    if not os.path.exists(log_path):
        return ":red-background[Failed - Log Missing]", 0.0, 0.0, 0.0, log_link

    try:
        with open(log_path, "r", encoding='utf-8', errors='ignore') as f:
            content = f.read()

        verify_matches = re.findall(r"Verify\s*:\s*\[[^\]]*\]\s*([0-9\.]+)%", content)
        if verify_matches: verify_p = float(verify_matches[-1]) / 100.0

        download_matches = re.findall(r"Download\s*:\s*\[[^\]]*\]\s*([0-9\.]+)%", content)
        if download_matches: download_p = float(download_matches[-1]) / 100.0

        build_matches = re.findall(r"Build\s*:\s*\[[^\]]*\]\s*([0-9\.]+)%", content)
        if build_matches: build_p = float(build_matches[-1]) / 100.0
        
        # 【修改】当 mrjet build 完成后，状态变为 Success，这将触发后续的修复流程
        if build_p >= 1.0:
            status, verify_p, download_p, build_p = ":green-background[Success]", 1.0, 1.0, 1.0
        elif "Error" in content or "ERROR:" in content:
            status = ":red-background[Failed]"
    except Exception as e:
        print(f"Error processing log file {log_path}: {e}")
        pass
    
    return status, verify_p, download_p, build_p, log_link

# --- Streamlit 介面 ---
st.title("MrJet WebGUI")

st.text_area(
    label="Enter one or more AV Numbers / URLs",
    placeholder="You can enter multiple items, separated by commas, spaces, or newlines.\ne.g.,\nwaaa-361, ssis-001",
    key="url_input_val"
)

add_col, start_col = st.columns((1, 5))
with add_col:
    add_button = st.button("Add", use_container_width=True)
with start_col:
    start_button = st.button("Start All Queued", use_container_width=True)

# --- 【重大修改】状态更新与自动修复逻辑 ---
for url, task in list(st.session_state.download_queue.items()):
    # 仅更新正在下载中的任务进度
    if task["Status"] == ":orange-background[Downloading]":
        status, p_v, p_d, p_b, log = check_task_status_and_progress(url, task["Log"])
        st.session_state.download_queue[url].update({
            "Status": status, "Progress_Verify": p_v, "Progress_Download": p_d, "Progress_Build": p_b, "Log": log
        })
    
    # 触发器：当 mrjet 下载完成时，立即进入修复状态
    if task["Status"] == ":green-background[Success]":
        st.session_state.download_queue[url]["Status"] = ":blue-background[Fixing]"

    # 如果任务处于修复状态，则执行修复操作
    if task["Status"] == ":blue-background[Fixing]":
        fix_success = find_and_fix_video(task["DisplayName"], DOWNLOAD_DIR)
        if fix_success:
            st.session_state.download_queue[url]["Status"] = ":green-background[Completed]"
        else:
            st.session_state.download_queue[url]["Status"] = ":red-background[Fix Failed]"

save_queue(st.session_state.download_queue)


# --- 佇列顯示 ---
st.markdown("---")
if not st.session_state.download_queue:
    st.info("The download queue is empty.")
else:
    for url, task in st.session_state.download_queue.items():
        main_cols = st.columns((5, 3, 2))
        main_cols[0].markdown(f'**ID:** [{task["DisplayName"]}]({url})')
        main_cols[1].text(f'Created: {task["Created Date"]}')
        main_cols[2].markdown(f'**{task["Status"]}** {task["Log"]}')
        # 【修改】当状态为修复中或已完成时，进度条显示为100%
        if task["Status"] in [":blue-background[Fixing]", ":green-background[Completed]"]:
            st.text("Verify:"); st.progress(1.0)
            st.text("Download:"); st.progress(1.0)
            st.text("Build:"); st.progress(1.0)
        else:
            st.text("Verify:"); st.progress(task["Progress_Verify"])
            st.text("Download:"); st.progress(task["Progress_Download"])
            st.text("Build:"); st.progress(task["Progress_Build"])
        st.markdown("---")

# --- 按鈕邏輯 (与之前版本保持一致) ---
if add_button and st.session_state.url_input_val:
    raw_input = st.session_state.url_input_val
    normalized_input = raw_input.replace(',', ' ').replace('\n', ' ')
    items_to_add = [item.strip() for item in normalized_input.split(' ') if item.strip()]
    added_count, skipped_count, exist_count = 0, 0, 0
    existing_files_list = []

    try:
        if not os.path.isdir(DOWNLOAD_DIR):
            st.error(f"Download directory not found: {DOWNLOAD_DIR}. Please create it or correct the path.")
            existing_filenames_normalized = []
        else:
            existing_filenames_normalized = [normalize_id(f) for f in os.listdir(DOWNLOAD_DIR) if os.path.isfile(os.path.join(DOWNLOAD_DIR, f))]
    except Exception as e:
        st.error(f"Error accessing download directory {DOWNLOAD_DIR}: {e}")
        existing_filenames_normalized = []

    for user_input in items_to_add:
        normalized_user_input = normalize_id(user_input)
        if any(normalized_user_input in filename for filename in existing_filenames_normalized):
            exist_count += 1
            existing_files_list.append(user_input)
            continue

        if not user_input.startswith("http"):
            full_url = f"{BASE_URL}{user_input}"
            display_name = user_input
        else:
            full_url = user_input
            display_name = user_input.split('/')[-1] or user_input
            
        if full_url not in st.session_state.download_queue:
            st.session_state.download_queue[full_url] = {
                "DisplayName": display_name, "Created Date": time.strftime("%Y-%m-%d %H:%M:%S"),
                "Status": ":gray-background[Not Started]", "Log": "",
                "Progress_Verify": 0.0, "Progress_Download": 0.0, "Progress_Build": 0.0,
            }
            added_count += 1
        else:
            skipped_count += 1
    
    if added_count > 0: st.success(f"Successfully added {added_count} new item(s).")
    if skipped_count > 0: st.warning(f"Skipped {skipped_count} item(s) already in queue.")
    if exist_count > 0: st.error(f"Skipped {exist_count} item(s) that may already exist: {', '.join(existing_files_list)}")
    
    if added_count > 0:
        save_queue(st.session_state.download_queue)
        st.rerun()

# --- 其他部分 (啟動、清理、自動刷新) ---
if start_button:
    for url, task in st.session_state.download_queue.items():
        if task["Status"] == ":gray-background[Not Started]":
            status, log_link = download_file(url)
            st.session_state.download_queue[url]["Status"] = status
            st.session_state.download_queue[url]["Log"] = log_link
    save_queue(st.session_state.download_queue)
    st.rerun()

with st.expander("Utils", expanded=False):
    if st.button("Clean finished tasks"):
        # 【修改】清理所有非进行中的任务
        urls_to_remove = [
            url for url, task in st.session_state.download_queue.items() 
            if task["Status"] not in [":orange-background[Downloading]", ":gray-background[Not Started]", ":blue-background[Fixing]"]
        ]
        for url in urls_to_remove:
            task = st.session_state.download_queue[url]
            if task["Log"]:
                log_file = task["Log"].split("/static/")[1].split(")")[0]
                log_path = os.path.join(static_dir, log_file)
                if os.path.exists(log_path): os.remove(log_path)
            del st.session_state.download_queue[url]
        save_queue(st.session_state.download_queue)
        st.rerun()

# 【修改】当有任务在下载或修复中时，自动刷新界面
is_processing = any(
    task["Status"] in [":orange-background[Downloading]", ":blue-background[Fixing]"] 
    for task in st.session_state.download_queue.values()
)
if is_processing:
    time.sleep(2)
    st.rerun()